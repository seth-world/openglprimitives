#ifndef ZOBJECTFUNCTIONS_H
#define ZOBJECTFUNCTIONS_H

#define __USE_ZARRAY_COPY_CONTRUCTOR__
#include <ztoolset/zarray.h>
#include <glm/glm.hpp>
#include <glm/ext.hpp>

#include <zobject.h>
#include <zboxcomponents.h>

unsigned int loadTexture(char const * path);

glm::vec3 calculateSurfaceNormal (Vertice_type* pTriangle);

glm::vec3 computeFaceNormal(glm::vec3 V1,   // v1
                            glm::vec3 V2,   // v2
                            glm::vec3 V3);   // v3

glm::vec3 computeFaceNormalFloat(float x1, float y1, float z1,  // v1
                                 float x2, float y2, float z2,  // v2
                                 float x3, float y3, float z3); // v3

const glm::vec3 calculateCenter(Vertice_type* pTriangle);
inline const glm::vec3 calculateCenter(Vertice_type &pTriangle1,
                                          Vertice_type &pTriangle2,
                                          Vertice_type &pTriangle3)
{
    Vertice_type wTriangle[3];
    wTriangle[0]=pTriangle1;
    wTriangle[1]=pTriangle2;
    wTriangle[2]=pTriangle3;
    return calculateCenter(wTriangle);
}


class ZCandy;

ZCandy
generateCandy (const float pHigh,
               const float pWidth,
               const float pDepth,
               bool pGenerateShape,              /* if true : generate shape indices */
               const char *pName);

/* remark: no shape is generated by this function : see ZBoxComponents::generateShape */
ZObject* boxIndexSetup (const float pHigh,
                       const float pWidth,
                       const float pDepth,
                       const char* pName);

/* remark: no shape is generated by this function : see ZBoxComponents::generateShape */
ZObject* boxIndexSetup (const float pHigh,
                       const float pWidth,
                       const float pDepth,
                       ZBoxComponents& pBoxComponents,
                       const char* pName);

/* remark: no shape is generated by this function : see ZBoxComponents::generateShape */
ZObject *boxSetup(const float pHigh,
                       const float pWidth,
                       const float pDepth,
                       const char* pName);
/* remark: no shape is generated by this function : see ZBoxComponents::generateShape */
ZObject* boxSetup (const float pHigh,
                  const float pWidth,
                  const float pDepth,
                  ZBoxComponents& pComponents,
                  const char*pName);

/* remark: no shape is generated by this function : see ZBoxComponents::generateShape */
ZObject *openboxSetup(const float pHigh,
                       const float pWidth,
                       const float pDepth,
                      ZBoxComponents& pComponents,
                      const char *pName);
/* remark: no shape is generated by this function : see ZBoxComponents::generateShape */
ZObject* openboxSetup (const float pHigh,
                       const float pWidth,
                       const float pDepth, bool pGenerateShape,
                      const char *pName);



zbs::ZArray<Vertice_type> perfect_arc_right_Front(Vertice_type pCenter,double pRadiusLen,  int pNumber);
zbs::ZArray<Vertice_type> perfect_arc_left_Front(Vertice_type pCenter,double pRadiusLen,  int pNumber);
zbs::ZArray<Vertice_type> perfect_arc_right_Back(Vertice_type pCenter,double pRadiusLen,  int pNumber);
zbs::ZArray<Vertice_type> perfect_arc_left_Back(Vertice_type pCenter, double pRadiusLen,  int pNumber);

ZObject *generate_Arc(Vertice_type pCenter,
                     float pRadiusLen,
                     int pNumber,
                     ZObject::Direction pDirection,
                     NormalDirection pNormDir,
                      bool pGenerateShape,              /* if true : generate shape indices */
                     const char *pName=nullptr);


ZObject* generate_ArcFrontBack(Vertice_type pCenter,
                               float pRadiusLen,
                               int pNumber,
                               int pFrontBack,          /* == 1 Front ; == 0 Back */
                               int pLeftRight,          /* == 1 Left ; == 0 Right */
                               bool pGenerateShape,
                               const char*pName);


/* remark: no shape is generated by this function */
ZObject *generate_ArcStripsRight(ZObject &pArcFront,
                                ZObject &pArcBack,
                                const char*pName=nullptr);

/* remark: no shape is generated by this function */
ZObject *generate_ArcStripsLeft(ZObject &pArcFront,
                                ZObject &pArcBack,
                                const char*pName=nullptr);

ZObject *generate_Circle(Vertice_type pCenter,
                         float pRadiusLen,
                         int pNumber,
                         ZObject::CircleMade pCircleDir,
                         NormalDirection pNormDir=Front,
                         const char *pName=nullptr);

/* Shape is generated by this function - normal and texture coordinates are computed too */
ZObject*
generateCylinderPointToPoint(glm::vec3 pBeginCenter,
                             glm::vec3 pTarget,
                             double pBeginRadius,
                             int pNumber,
                             const char* pName);


/* remark: no shape is generated by this function */
ZObject*
generateCylinder(Vertice_type pBeginCenter,
                 double pBeginRadius,
                 Vertice_type pTargetCenter,
                 double pTargetRadius,
                 int pNumber,
                 ZObject::CircleMade pBeginCircleState,
                 ZObject::CircleMade pTargetCircleState,
                 const char*pName=nullptr);

/* remark: no shape is generated by this function */
ZObject*
generateRegularCylinder(Vertice_type pBeginCenter,
                        Vertice_type pTargetCenter,
                        float pRadius,
                        int pNumber,
                        ZObject::CircleMade pCircleState,
                        const char*pName=nullptr);

/**
 * @brief generateDiskNorm generates circle coordinates perpendicular to MAIN vector direction.
 * Resulting circle will be aligned either on x plane or on y plane or on z plane.
 * @param pOrigin
 * @param pRadius
 * @param pDirection
 * @param pNumber
 * @return
 */
zbs::ZArray<glm::vec3>
generateDiskNorm(glm::vec3 pOrigin, double pRadius,glm::vec3 pDirection,int pNumber);

/**
 * @brief generateDiskNorm generates circle coordinates perpendicular to vector direction.
 * @param pOrigin
 * @param pRadius
 * @param pDirection
 * @param pNumber
 * @return
 */
zbs::ZArray<glm::vec3>
generateDisk(glm::vec3 pOrigin, double pRadius,glm::vec3 pDirection,int pNumber);

/**
 * @brief getMainDirection computes the main direction of a vector pDirection (either positive or negative)
 * @param pDirection
 * @return
 */
glm::vec3 getMainDirection(glm::vec3 pDirection);

#endif // ZOBJECTFUNCTIONS_H
